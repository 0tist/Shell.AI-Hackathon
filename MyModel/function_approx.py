# -*- coding: utf-8 -*-
"""function approx.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p-hYMRMo5wgBAUeA0w0hUJ4cUqKGiSoG
"""

import math 
  
# Function to calculate value using  
# Stirling formula 
def Stirling(x, fx, x1, n): 
    out = []
    y1 = 0; N1 = 1; d = 1; 
    N2 = 1; d2 = 1;  
    temp1 = 1; temp2 = 1; 
    k = 1; l = 1;  
    delta = [[0 for i in range(n)] 
                for j in range(n)]; 
  
    h = x[1] - x[0]; 
    s = math.floor(n / 2); 
    a = x[s]; 
    u = (x1 - a) / h; 
  
    # Preparing the forward difference 
    # table 
    for i in range(n - 1):  
        delta[i][0] = fx[i + 1] - fx[i]; 
    for i in range(1, n - 1): 
        for j in range(n - i - 1): 
            delta[j][i] = (delta[j + 1][i - 1] - 
                           delta[j][i - 1]); 
  
    # Calculating f(x) using the Stirling formula 
    y1 = fx[s]; 
  
    for i in range(1, n): 
        if (i % 2 != 0):  
            if (k != 2):  
                temp1 *= (pow(u, k) - pow((k - 1), 2)); 
            else: 
                temp1 *= (pow(u, 2) - pow((k - 1), 2)); 
            k += 1; 
            d *= i; 
            s = math.floor((n - i) / 2); 
            y1 += (temp1 / (2 * d)) * (delta[s][i - 1] + 
                                       delta[s - 1][i - 1]); 
        else: 
            temp2 *= (pow(u, 2) - pow((l - 1), 2)); 
            l += 1; 
            d *= i; 
            s = math.floor((n - i) / 2); 
            y1 += (temp2 / (d)) * (delta[s][i - 1]); 
  
    return round(y1, 9)

def ucal(u, n): 
  
    if (n == 0): 
        return 1; 
  
    temp = u; 
    for i in range(1, int(n / 2 + 1)): 
        temp = temp * (u - i); 
  
    for i in range(1, int(n / 2)): 
        temp = temp * (u + i); 
  
    return temp; 
  
# calculating factorial of  
# given number n 
def fact(n): 
  
    f = 1; 
    for i in range(2, n + 1): 
        f *= i; 
  
    return f; 
  
# Number of values given 
n = 5; 
x = [0, 0.5, 1.0, 1.5, 2.0 ];  
  
# y[][] is used for difference  
# table with y[][0] used for input 
y = [[0 for i in range(n)]  
        for j in range(n)]; 
y[0][0] = 0.000 
y[1][0] = 0.191
y[2][0] = 0.341 
y[3][0] = 0.433
y[4][0] = 0.477
  
# Calculating the central 
# difference table 
def bessel(n, x, y):
  for i in range(1, n): 
    for j in range(n - i): 
        y[j][i] = y[j + 1][i - 1] - y[j][i - 1]; 
  
  # Displaying the central 
  # difference table 
  for i in range(n):  
    for j in range(n - i): 
        print(y[i][j], "\t", end = " "); 
    print(""); 
  
  # value to interpolate at 
  value = 1.25; 
  
  # Initializing u and sum 
  sum = (y[2][0] + y[3][0]) / 2; 
  
  # k is origin thats is f(0) 
  k = 0; 
  if ((n % 2) > 0): # origin for odd 
    k = int(n / 2); 
  else: 
    k = int(n / 2 - 1); # origin for even 
  
  u = (value - x[k]) / (x[1] - x[0]); 
  
  # Solving using bessel's formula 
  for i in range(1, n):  
  
    if (i % 2): 
        sum = sum + ((u - 0.5) *
                 ucal(u, i - 1) *
              y[k][i]) / fact(i); 
    else: 
        sum = sum + (ucal(u, i) * (y[k][i] + 
                     y[k - 1][i]) / (fact(i) * 2)); 
        k -= 1; 
  
  print("Value at", value, "is", round(sum, 5)); 
  return round(sum,9)

# Driver Code 
n = 5
x = [0, 0.5, 1.0, 1.5, 2.0 ]
fx = [ 0, 0.191, 0.341, 0.433, 0.477]
  
# Value to calculate f(x) 
x1 = 1.25; 
print(Stirling(x, fx, x1, n))

bessel(n, x, y)

import pandas as pd
import numpy as np
df = pd.read_csv('power_curve.csv')

df['Wind Speed (m/s)'] = df['Wind Speed (m/s)'].astype(np.float)
df['Thrust Coeffecient'] = df['Thrust Coeffecient'].astype(np.float)

n = 501
x = df['Wind Speed (m/s)'].values
fx = x1 = df['Thrust Coeffecient'].values
a = Stirling(x, fx, x1, n)